!------------------------------------------------------------!
! This file is distributed as part of the cpw2000 code and   !
! under the terms of the GNU General Public License. See the !
! file `LICENSE' in the root directory of the cpw2000        !
! distribution, or http://www.gnu.org/copyleft/gpl.txt       !
!                                                            !
! The webpage of the cpw2000 code is not yet written         !
!                                                            !
! The cpw2000 code is hosted on GitHub:                      !
!                                                            !
! https://github.com/jlm785/cpw2000                          !
!------------------------------------------------------------!

!>  writes a CIF file for later use
!>
!>  \author       Jose Luis Martins
!>  \version      5.12
!>  \date         April 2021, 9 June 2025.
!>  \copyright    GNU Public License v2

subroutine write_cif(filename,                                           &
    adot, ntype, natom, nameat, rat,                                     &
    mxdtyp, mxdatm)

! Adapted April 2021. JLM
! Added comments with links, filename. 9 June 2025. JLM

  implicit none

  integer, parameter  :: REAL64 = selected_real_kind(12)

! input:

  integer, intent(in)                ::  mxdtyp                          !<  array dimension of types of atoms
  integer, intent(in)                ::  mxdatm                          !<  array dimension of types of atoms

  character(len=*), intent(in)       ::  filename                        !<  name of cif file

  real(REAL64), intent(in)           ::  adot(3,3)                       !<  metric in direct space
  integer, intent(in)                ::  ntype                           !<  number of types of atoms
  integer, intent(in)                ::  natom(mxdtyp)                   !<  number of atoms of type i
  character(len=2), intent(in)       ::  nameat(mxdtyp)                  !<  chemical symbol for the type i
  real(REAL64), intent(in)           ::  rat(3,mxdatm,mxdtyp)            !<  k-th component (in lattice coordinates) of the position of the n-th atom of type i

! local:

  real(REAL64)       ::  a, b, c
  real(REAL64)       ::  alfa, beta, gama

  character(len=9)   ::  bdate
  character(len=6)   ::  label
  character(len=2)   ::  elem
  integer            ::  io                         !  tape number

! parameters

  real(REAL64), parameter    ::  BOHR = 0.5291772109_REAL64
  real(REAL64), parameter    ::  PI = 3.14159265358979323846_REAL64
  real(REAL64), parameter    ::  DEGREE = 180.0_REAL64


! counters

  integer       ::  nt, i, j


! open file

  io = 10

  open(unit = io, file = adjustl(trim(filename)), status='UNKNOWN', form='FORMATTED')

  call zedate(bdate)

  write(io,'(72a1)') ("#",j=1,72)
  write(io,'("#",70x,"#")')
  write(io,'("#",6x," minimal CIF file generated by cpw2000/rede/pre-relax",11x,"#")')
  write(io,'("#",6x," on the ",a9,47x,"#")') bdate
  write(io,'("#",70x,"#")')
  write(io,'("#",6x," try https://stokes.byu.edu/iso/findsym.php for symmetry",8x,"#")')
  write(io,'("#",6x," try https://pypi.org/project/cif2cell/ to convert",14x,"#")')
  write(io,'("#",70x,"#")')
  write(io,'(72a1)') ("#",j=1,72)


  a = sqrt(adot(1,1))
  b = sqrt(adot(2,2))
  c = sqrt(adot(3,3))

  alfa = acos(adot(2,3)/(b*c))
  beta = acos(adot(3,1)/(c*a))
  gama = acos(adot(1,2)/(a*b))

  a = a*BOHR
  b = b*BOHR
  c = c*BOHR

  alfa = alfa*DEGREE/PI
  beta = beta*DEGREE/PI
  gama = gama*DEGREE/PI

  write(io,'("data_cpw2000")')
  write(io,'("   _symmetry_space_group_name_H-M    ''P 1'' ")')
  write(io,'("   _symmetry_Int_Tables_number   1")')
  write(io,'("   _cell_formula_units_Z   1")')

  write(io,'("   _cell_length_a",5x,f20.10)') a
  write(io,'("   _cell_length_b",5x,f20.10)') b
  write(io,'("   _cell_length_c",5x,f20.10)') c

  write(io,'("   _cell_angle_alpha",5x,f20.10)') alfa
  write(io,'("   _cell_angle_beta",6x,f20.10)') beta
  write(io,'("   _cell_angle_gamma",5x,f20.10)') gama

  write(io,'("loop_")')
  write(io,'("   _symmetry_equiv_pos_site_id")')
  write(io,'("   _symmetry_equiv_pos_as_xyz")')
  write(io,'("      1  ''x, y, z'' ")')


  write(io,'("loop_")')
  write(io,'("   _atom_site_type_symbol")')
  write(io,'("   _atom_site_label")')
  write(io,'("   _atom_site_symmetry_multiplicity")')
  write(io,'("   _atom_site_fract_x")')
  write(io,'("   _atom_site_fract_y")')
  write(io,'("   _atom_site_fract_z")')
  write(io,'("   _atom_site_occupancy")')

  do nt = 1,ntype
  do i = 1,natom(nt)
    elem = nameat(nt)
    label = '      '
    if(elem(2:2) == ' ') then
      if(i < 10) then
        write(label,'(a1,i1)') elem(1:1),i
      elseif(i < 100) then
        write(label,'(a1,i2)') elem(1:1),i
      elseif(i < 1000) then
        write(label,'(a1,i3)') elem(1:1),i
      else
        write(label,'(a1,i4)') elem(1:1),i
      endif
    else
      if(i < 10) then
        write(label,'(a2,i1)') elem,i
      elseif(i < 100) then
        write(label,'(a2,i2)') elem,i
      elseif(i < 1000) then
        write(label,'(a2,i3)') elem,i
      else
        write(label,'(a2,i4)') elem,i
      endif
    endif
    write(io,'(6x,a2,3x,a6,3x,"1",3x,3f16.8,3x,"1")')                    &
                     elem,label,(rat(j,i,nt),j=1,3)
  enddo
  enddo

  close(unit = io)

  return

end subroutine write_cif

